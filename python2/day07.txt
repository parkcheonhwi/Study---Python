day07
복습 -> 스택 -> 큐 -> 원형큐(링버퍼) -> 정렬

0. 복습
자료구조
   단순구조, 선형구조, 비선형구조, 파일구조

연결리스트
   노드(Node)들이 서로 연결된 형태로 구성된 선형 자료구조
      노드 : 데이터 + 다음 노드의 주소

단일원형연결리스트
   단순연결리스트의 마지막 노드가 다시 첫번째 노드를 가리키도록 설정되어
   리스트 형태가 원형형태로 구성
   
1. 스택(Stack)
   데이터가 입력되면 입력되는 순서대로 쌓고 나중에 들어온것부터 먼저 사용하는 자료구조
   후입선출형, LIFO형
   
1) 스택의 추상데이터 타입(ADT)
   맨 윗부분에 요소를 추가한다
   맨 윗부분에 있는 요소를 알려준다
   맨 위부분에 있는 요소를 삭제하면서 알려준다
   스택이 비어있는지 확인한다
   스택을 깨끗이 비운다

2) 함수
   push() : bottom부터 차례대로 삽입이 된다
   pop() : top부터 차례대로 삭제되며 top에 해당하는 값을 반환한다
   peek() : top에 있는 요소를 알려준다(검색)
   clear() : 스택에 모든 요소 삭제(removeAll)

3) 필요연산
   create(size) : 스택을 생성(초기화)
   is_empty() : 스택이 비어있다면 True, 아니라면 False
   is_full() : 스택이 가득 차있다면 True, 아니라면 False
   push(item) : 만약 size를 초과한다면 False
   pop() : top에 위치한 item 반환하면서 제거
   peek() : top에 위치한 item 반환

   top : 스택의 윗부분(push, pop이루어지는 부분)
   bottom : 스택의 아랫부분(인덱스가 0인 요소)
   capacity : 스택의 최대 크기(int형)
   스택포인터 ptr : 스택에 쌓여있는 데이터의 개수를 나타내는 정수값을 의미

4) 스택에서의 예외처리
   빈 스택에서 데이터를 꺼내려고할 때
   가득찬 스택에 데이터를 넣으려고 할 때

5) 알고리즘 대회 스택 활용 문제
   괄호 검사 (){}[]
   수식 계산
   미로 탐색
   스택을 활용한 깊이 우선 탐색

+) 중위표기법 vs 후위 표기법
   중위표기법 : 피연산자 사이에 연산자를 표현하는 방법(사람이 사용하는 수식)
      연산자의 우선순위를 직접 판단
   후위표기법 : 피연산자 뒤쪽에 연산자를 표현하는 방법(컴퓨터가 사용하는 수식)
      연산자의 우선순위를 계산할 필요가 없음


중위표기법 -> 후위표기법 
res : 후위 표기법으로 바꾼 결과를 저장해줄 문자배열
1. 숫자가 나왔다면 res에 바로 담아준다
2. 연산자가 나왔다면
   2-1. 스택에 연산자가 없거나 본인의 우선순위가 스택에 저장되어 있는 연산자보다 높다면 push
   2-2. 본인의 우선순위가 스택에 저장되어 있는 연산자보다 낮거나 같다면 본인보다
      우선순위가 낮은 연산자가 top이 될 때까지 스택에서 pop()하여 res에 추가하고
      본인은 스택에 push()
3. 소괄호추가
   3-1. (여는 소괄호는 무조건 스택에 push()
   3-2. )닫는 소괄호는 스택에서 (여는 소괄호를 만날때까지 모든 요소를 pop()하여 res에 추가
4. 만약 중위표기법의 순회가 끝났다면 스택에 남아있는 연산자를 모두 pop하여 res에 추가


후위표기법 계산
1. 숫자가 나왔다면 스택에 담아준다
2. 연산자가 나왔다면 스택에서 숫자를 두 번 pop하여 연산 후 다시 스택 push한다
3. 마지막에 스택에 남은 숫자가 결과이다

2. 큐(Queue)
   가장 먼저 넣은 데이터를 가장 먼저 꺼내는 구조
   선입선출형, FIFO(First In First Out)형
   
   큐의 구현 : 배열을 이용(순환 큐), 연결리스트 이용(링크드 큐)

1) 큐 자료구조의 용도
   데이터의 흐름을 제어하는 데 사용(프로세스간 통신에서 메시지를 전송하거나, 네트워크 트래픽을
   조절하는 등의 용도)
   BFS(Breadth First Search) : 그래프 자료구조에서 사용되는 대표적인 탐색알고리즘 중 하나

2) 활용예시
   프린터의 출력처리(스풀링)
   프로세스 관리 등 작업 스케줄링
   
3) 큐의 ADT
   맨 끝에 요소를 추가한다
   맨 앞의 요소를 삭제하면서 알려준다
   맨 앞의 요소를 알려준다
   큐가 비어있는지 확인한다
   큐를 깨끗이 비운다

3) 주요함수
   enqueue() : 큐 뒤쪽에 항목을 삽입한다
   dequeue() : 큐 앞쪽의 항목을 반환하고 제거한다
   peek/front : 큐 앞쪽 항목을 조회한다
   empty : 큐가 비어있는지 확인한다
   size : 큐의 크기를 확인한다

4) 필요연산
   create(size) : 큐를 생성(초기화)
   is_empty() : 큐가 비어있다면 True, 아니라면 False
   is_full() : 큐가 가득차있다면 True, 아니라면 False
   enqueue() : 큐에 데이터를 추가
   dequeue() : 큐에서 데이터를 삭제
   peek() : 맨 처음 데이터를 반환(디큐에서 꺼내질 데이터)

3. 링 버퍼(원형큐)
   디큐할 때 배열안의 요소를 옮기지 않는 큐를 구현할 때 사용
   배열 맨 끝의 요소 뒤에 맨 앞의 요소가 연결되는 자료구조
   사용이유 : 인덱스번호가 이동하게 되는데 링버퍼를 사용하면 선형큐의 문제를 해결할 수 있다

   front : 가장 최근에 삭제된 항목의 위치를 저장
      맨 앞 요소의 인덱스(디큐할 위치)
   rear : 가장 최근에 삽입된 항목의 위치를 저장
      맨 끝 요소 바로 뒤의 인덱스(다음 인큐되는 데이터가 저장되는 위치)

+) 알고리즘 대회 큐 활용 문제
   BFS(너비우선탐색) 문제
   큐 시뮬레이션 문제
   문자열 처리 문제(팰린드롬 검사, 문자열 변환 등)
   스케줄링 문제
   
4. 정렬 알고리즘
   정렬 : 자료들을 일정한 순서대로 나열하는 것을 의미
   기본정렬 : 선택정렬, 삽입정렬, 버블정렬 => 보통 O(n²) 
   고급정렬 : 병합정렬, 퀵정렬, 힙정렬, 셸정렬 => 보통 O(nlog n)
   특수정렬 : 계수정렬, 기수정렬, 버킷정렬 => 보통 O(n)

+) 안정정렬과 불안정정렬
   => 중복된 값의 정렬순서에 대한 보장여부가 중요한 요소
   안정정렬 : 중복된 값을 입력순서와 동일하게 정렬한다
      기존의 다른 요소로 정렬이 된 입력값을 정렬시에 기존 정렬형태를 
      유지한 상태에서 정렬한다

   불안정정렬 : 중복된 값을 입력순서와 상관없이 무작위로 뒤섞인 상태에서 정렬한다
      동일한 입력값에 대해서 중복된 값의 순서에 대한 보장이 없다.
      같은 값이 여러개 있을 때 정렬 결과가 알수없는 상황이 발생할 수 있다

   (ex) [3, 2, 1, 5, 7, 5] 배열 오름차순으로 정렬한다[1, 2, 3, 5, 5, 7]


1) 선택정렬(Select Sort)
   한 바퀴를 돌 때 최소값을 뽑아 첫번째 요소와 교환하고 그 다음으로 작은 값을 찾아
   두번째 요소와 교환하여 정렬하는 방식
   불안정정렬, 선택정렬의 시간복잡도는 O(n²)

   구현방법
   리스트에서 가장 작은 항목을 찾아서 첫번째 항목과 위치를 바꾼다
   그다음으로 작은 항목을 찾아서 두번째 항목과 위치를 바꾼다
   리스트 끝에 도달할 때까지 이 과정을 반복한다

2) 삽입정렬(=셔틀정렬, Insert Sort)
   기존 데이터 중에서 자신의 위치를 찾아서 데이터를 삽입하는 정렬 방식
   미리 정렬된 리스트에 새 항목을 추가할 때 좋은 정렬 알고리즘
   역순으로 정렬되어 있는 경우는 최악의 경우가 됨
   많은 데이터들이 이동해야하기 때문에 데이터가 많을 경우에는 적합하지 않음
   불안정정렬, 최선의 경우 O(n), 최악의 경우 O(n²)
   대부분의 정렬 알고리즘보다 상대적으로 느림

   구현방법
   전제조건 : 삽입할 위치를 찾는 기존 배열은 이미 정렬되어있다
   배열에 삽입할 값보다 큰 값을 처음부터 비교하면서 자신보다 큰 값을 만나게 되면 그 바로 앞에
   삽입한다
   -> 배열에 삽입할 값보다 큰 값이 없을 때 맨 뒤에 삽입후에 비교대상에서 제외한다

3) 버블정렬
   인접한 두 수를 비교하여 큰 수를 오른쪽으로 작은 수를 왼쪽으로 교환하며 정렬하는 알고리즘
   이웃하는 숫자를 비교하여 특정수(최대값/최소값)를 한 쪽으로 이동시키는 알고리즘
   (첫번째값보다 바로 앞뒤 데이터를 비교하여 큰 것은 뒤로 보내는 정렬방식)
   안정정렬, 시간 복잡도 최악/최선/평균 모두 O(n²)

   구현방법
   배열의 첫번째 인덱스부터 시작하여 인접한 두 수를 비교한다
   만약 첫번째 수가 두번째 수보다 크면 두수의 위치를 서로 교환한다
   배열의 마지막 인덱스까지 1, 2번 과정을 반복한다
   마지막 인덱스까지 1,2번과정을 반복하면서 정렬된 부분의 크기를 점차적으로 늘려간다
      - 정렬이 완료되면 배열의 가장 마지막 인덱스부터 정렬이 완료된 부분이 채워지며
      정렬이 완료된 배열을 얻을 수 있다

4) 병합정렬(Merge Sort)
   분할정복과 재귀를 이용한 알고리즘
   분할정복 알고리즘의 대표적인 예
   데이터를 최소단위로 쪼갠 후, 병합하며 정렬하는 방법
   안정정렬, O(n log n)
   추가적인 메모리 공간이 필요함
   
   구현
   재귀함수를 이용

+) 재귀함수(Recursive Function)
   자기자신을 호출하는 함수
